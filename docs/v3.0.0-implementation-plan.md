# Functional Library v3.0.0 Implementation Plan

**Version:** 3.0.0
**Date:** December 06, 2025
**Branch:** feature/v3.0.0-api-redesign
**Status:** Planning

---

## Overview

This release introduces breaking changes to improve API ergonomics:
1. Boolean discriminants replacing enumeration types
2. Ada operator overloading for natural syntax
3. Full word naming (no abbreviations)
4. New functional operations (Zip_With, Flatten, conversions)
5. Ada 2022 features where beneficial

---

## Design Decisions (Confirmed)

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Tuple for Zip | User-supplied via `Zip_With` | Ada lacks built-in tuples; `Zip_With` is primary |
| Cross-package conversions | Generic formals | No circular dependencies; maximum flexibility |
| Either bias | Right-biased | Standard in Scala/Haskell for `And_Then`/`Map` |
| Preelaborate | Maintain compatibility | Boolean discriminants are Preelaborate-safe |

---

## Part 1: Discriminant Redesign

### 1.1 Option Type

**Before:**
```ada
type Option_Kind is (K_Some, K_None);
type Option (Kind : Option_Kind := K_None) is record
   case Kind is
      when K_Some => Value : T;
      when K_None => null;
   end case;
end record;

--  Usage: if O.Kind = K_Some then
```

**After:**
```ada
type Option (Has_Value : Boolean := False) is record
   case Has_Value is
      when True  => Value : T;
      when False => null;
   end case;
end record;

--  Usage: if O.Has_Value then
```

**Predicate Simplification:**
```ada
--  Before
function Is_Some (O : Option) return Boolean is (O.Kind = K_Some);
function Is_None (O : Option) return Boolean is (O.Kind = K_None);

--  After
function Is_Some (O : Option) return Boolean is (O.Has_Value);
function Is_None (O : Option) return Boolean is (not O.Has_Value);
```

### 1.2 Result Type

**Before:**
```ada
type Result_Kind is (K_Ok, K_Err);
type Result (Kind : Result_Kind := K_Ok) is record
   case Kind is
      when K_Ok  => Ok_Value  : T;
      when K_Err => Err_Value : E;
   end case;
end record;
```

**After:**
```ada
type Result (Is_Ok : Boolean := True) is record
   case Is_Ok is
      when True  => Ok_Value    : T;
      when False => Error_Value : E;
   end case;
end record;

--  Usage: if R.Is_Ok then
```

### 1.3 Either Type

**Before:**
```ada
type Either_Kind is (K_Left, K_Right);
type Either (Kind : Either_Kind := K_Left) is record
   case Kind is
      when K_Left  => Left_Value  : L;
      when K_Right => Right_Value : R;
   end case;
end record;
```

**After:**
```ada
type Either (Is_Left : Boolean := True) is record
   case Is_Left is
      when True  => Left_Value  : L;
      when False => Right_Value : R;
   end case;
end record;

--  Usage: if E.Is_Left then
```

---

## Part 2: Naming Changes (Abbreviations → Full Words)

### 2.1 Result Type Renames

| Current | New | Type |
|---------|-----|------|
| `Err` | `New_Error` | Constructor (parallels `New_Some`) |
| `Err_Value` | `Error_Value` | Record field |
| `Is_Err` | `Is_Error` | Predicate |
| `Map_Err` | `Map_Error` | Transformation |
| `Tap` (On_Err) | `Tap` (On_Error) | Generic formal parameter |
| `Err_U` | `Error_U` | Generic formal in `And_Then_Into` |

### 2.2 Consistency Check

| Package | Constructor Pattern | Notes |
|---------|---------------------|-------|
| Option | `New_Some`, `None` | Already consistent |
| Result | `Ok`, `New_Error` | `Ok` stays (no collision) |
| Either | `Left`, `Right` | Already full words |

---

## Part 3: Ada Operator Overloading

### 3.1 Option Operators

```ada
--  Operator aliases for existing functions
function "or" (O : Option; Default : T) return T renames Unwrap_Or;
function "or" (A, B : Option) return Option renames Or_Else;

--  New operations with operators
function "and" (A, B : Option) return Option;
--  Returns B if both have values, else None
--  Implementation: if A.Has_Value and B.Has_Value then B else None

function "xor" (A, B : Option) return Option;
--  Returns the value if exactly one has a value
--  Implementation:
--    if A.Has_Value and not B.Has_Value then A
--    elsif B.Has_Value and not A.Has_Value then B
--    else None
```

**Usage Examples:**
```ada
--  Fallback chain
Port : String := Port_Option or Env_Option or "/dev/ttyACM0";

--  Both required
if Config_A and Config_B then
   Process (Config_B);  --  "and" returns second operand
end if;

--  Exactly one
Choice := Option_A xor Option_B;
```

### 3.2 Result Operators

```ada
--  Operator aliases for existing functions
function "or" (R : Result; Default : T) return T renames Unwrap_Or;
function "or" (A, B : Result) return Result renames Fallback;
```

### 3.3 Either Operators

```ada
--  Swap Left/Right
function "not" (E : Either) return Either;
--  Implementation: Swaps Left_Value ↔ Right_Value
--  Note: Return type changes to Either(R, L) - requires new generic
```

**Ada 2022 Consideration for Either "not":**
The `not` operator swapping `Either[L,R]` to `Either[R,L]` requires a different return type. Options:
1. Separate generic `Swap` function returning user-provided swapped Either type
2. Constrain to `L = R` cases only for operator
3. Provide `Swap` as generic, not as operator

**Recommendation:** Provide `Swap` as a generic function (not operator) since return type differs:
```ada
generic
   type Swapped_Either is private;
   with function Make_Left (V : R) return Swapped_Either;
   with function Make_Right (V : L) return Swapped_Either;
function Swap (E : Either) return Swapped_Either;
```

---

## Part 4: New Operations

### 4.1 Option New Operations

#### Zip_With (Primary combining operation)
```ada
generic
   type U is private;
   type V is private;
   type Option_U is private;
   with function Has_Value_U (O : Option_U) return Boolean;
   with function Value_U (O : Option_U) return U;
   with function Combine (A : T; B : U) return V;
function Zip_With (A : Option; B : Option_U) return Option;
--  Returns Some(Combine(A.Value, B.Value)) if both have values, else None
--  Ada 2022: Could use declare expression for clarity
```

#### Flatten
```ada
generic
   type Inner_Option is private;
   with function Has_Value_Inner (O : Inner_Option) return Boolean;
   with function Value_Inner (O : Inner_Option) return T;
function Flatten (O : Option) return Option
  with Pre => (if O.Has_Value then O.Value'Valid);
--  Option[Option[T]] → Option[T]
--  Returns inner option if outer has value, else None
```

#### Ok_Or (Convert to Result)
```ada
generic
   type Error_Type is private;
   type Result_Type is private;
   with function Make_Ok (V : T) return Result_Type;
   with function Make_Error (E : Error_Type) return Result_Type;
function Ok_Or (O : Option; Error : Error_Type) return Result_Type;
--  Some(v) → Ok(v), None → Error(e)
```

#### Ok_Or_Else (Lazy error)
```ada
generic
   type Error_Type is private;
   type Result_Type is private;
   with function Make_Ok (V : T) return Result_Type;
   with function Make_Error (E : Error_Type) return Result_Type;
   with function Produce_Error return Error_Type;
function Ok_Or_Else (O : Option) return Result_Type;
--  Some(v) → Ok(v), None → Error(Produce_Error())
```

### 4.2 Result New Operations

#### Zip_With
```ada
generic
   type U is private;
   type V is private;
   type Result_U is private;
   with function Is_Ok_U (R : Result_U) return Boolean;
   with function Value_U (R : Result_U) return U;
   with function Error_U (R : Result_U) return E;
   with function Make_Ok (Val : V) return Result;
   with function Make_Error (Err : E) return Result;
   with function Combine (A : T; B : U) return V;
function Zip_With (A : Result; B : Result_U) return Result;
--  Both Ok → Ok(Combine), else first Error
```

#### Flatten
```ada
generic
   type Inner_Result is private;
   with function Is_Ok_Inner (R : Inner_Result) return Boolean;
   with function Value_Inner (R : Inner_Result) return T;
   with function Error_Inner (R : Inner_Result) return E;
function Flatten (R : Result) return Result;
--  Result[Result[T,E],E] → Result[T,E]
--  Ok(Ok(v)) → Ok(v), Ok(Err(e)) → Err(e), Err(e) → Err(e)
```

#### To_Option
```ada
generic
   type Option_Type is private;
   with function Make_Some (V : T) return Option_Type;
   with function Make_None return Option_Type;
function To_Option (R : Result) return Option_Type;
--  Ok(v) → Some(v), Error(_) → None
```

### 4.3 Either New Operations

#### And_Then (Right-biased monadic bind)
```ada
generic
   type U is private;
   type Either_U is private;
   with function Make_Left (V : L) return Either_U;
   with function F (V : R) return Either_U;
function And_Then (E : Either) return Either_U;
--  Left(l) → Left(l), Right(r) → F(r)
```

#### Map (Right-biased)
```ada
generic
   type U is private;
   type Either_U is private;
   with function Make_Left (V : L) return Either_U;
   with function Make_Right (V : U) return Either_U;
   with function F (V : R) return U;
function Map (E : Either) return Either_U;
--  Left(l) → Left(l), Right(r) → Right(F(r))
```

#### Swap
```ada
generic
   type Swapped_Either is private;
   with function Make_Left (V : R) return Swapped_Either;
   with function Make_Right (V : L) return Swapped_Either;
function Swap (E : Either) return Swapped_Either;
--  Left(l) → Right(l), Right(r) → Left(r)
```

---

## Part 5: Ada 2022 Features to Leverage

### 5.1 Declare Expressions
Use for local bindings in expression functions:
```ada
function Zip_With (A : Option; B : Option_U) return Option is
  (declare
     Both_Present : constant Boolean := A.Has_Value and Has_Value_U (B);
   begin
     (if Both_Present
      then New_Some (Combine (A.Value, Value_U (B)))
      else None));
```

### 5.2 Contract Aspects (Already Using)
Continue using `Pre`, `Post`, `Inline` aspects.

### 5.3 Expression Functions
Prefer expression functions for simple operations:
```ada
function Is_Some (O : Option) return Boolean is (O.Has_Value) with Inline;
function Is_None (O : Option) return Boolean is (not O.Has_Value) with Inline;
```

### 5.4 Aspect Specifications
Group aspects cleanly:
```ada
function "or" (O : Option; Default : T) return T
  with Inline,
       Post => "or"'Result = (if O.Has_Value then O.Value else Default);
```

---

## Part 6: Implementation Order

### Phase 1: Core Breaking Changes (Must do together)
1. [ ] Option: Discriminant `Kind` → `Has_Value`
2. [ ] Result: Discriminant `Kind` → `Is_Ok`, field `Err_Value` → `Error_Value`
3. [ ] Either: Discriminant `Kind` → `Is_Left`
4. [ ] Result: Rename `Err` → `New_Error`
5. [ ] Result: Rename `Is_Err` → `Is_Error`
6. [ ] Result: Rename `Map_Err` → `Map_Error`
7. [ ] Update all tests for new discriminants and names
8. [ ] Verify build and tests pass

### Phase 2: Operator Aliases (Low risk)
1. [ ] Option: Add `"or"` operators
2. [ ] Result: Add `"or"` operators
3. [ ] Add operator tests
4. [ ] Verify Preelaborate still works for Option

### Phase 3: New Option Operations
1. [ ] Option: `"and"` operator
2. [ ] Option: `"xor"` operator
3. [ ] Option: `Zip_With`
4. [ ] Option: `Flatten`
5. [ ] Option: `Ok_Or`, `Ok_Or_Else`
6. [ ] Add tests for each

### Phase 4: New Result Operations
1. [ ] Result: `Zip_With`
2. [ ] Result: `Flatten`
3. [ ] Result: `To_Option`
4. [ ] Add tests for each

### Phase 5: New Either Operations
1. [ ] Either: `And_Then` (right-biased)
2. [ ] Either: `Map` (right-biased)
3. [ ] Either: `Swap`
4. [ ] Add tests for each

### Phase 6: Documentation
1. [ ] Update quick_start.md
2. [ ] Update README.md with new operation counts
3. [ ] Write migration guide in CHANGELOG.md
4. [ ] Update formal docs (SRS, SDS)

---

## Part 7: Test Strategy

### New Test Counts (Estimated)

| Package | Current | New Tests | Total |
|---------|---------|-----------|-------|
| Option | 22 | +12 (operators, Zip_With, Flatten, Ok_Or) | ~34 |
| Result | 43 | +8 (operators, Zip_With, Flatten, To_Option) | ~51 |
| Either | 16 | +9 (And_Then, Map, Swap) | ~25 |
| **Total** | 101 | +29 | ~130 |

### Test Categories per New Operation
- Happy path (success case)
- Sad path (None/Error case)
- Edge cases (empty, boundary values)
- Operator precedence verification

---

## Part 8: Migration Guide

```
================================================================================
                    v2.3.0 → v3.0.0 Migration Guide
================================================================================

1. DISCRIMINANT CHANGES
   Replace enumeration checks with Boolean checks:

   Option:
     Before: if O.Kind = K_Some then
     After:  if O.Has_Value then

     Before: case O.Kind is when K_Some => ... when K_None => ...
     After:  case O.Has_Value is when True => ... when False => ...

   Result:
     Before: if R.Kind = K_Ok then
     After:  if R.Is_Ok then

     Before: R.Kind = K_Err
     After:  not R.Is_Ok

   Either:
     Before: if E.Kind = K_Left then
     After:  if E.Is_Left then

2. FUNCTION RENAMES
   Result package:
     Err(...)      →  New_Error(...)
     Is_Err(R)     →  Is_Error(R)
     Map_Err       →  Map_Error

   Record field (if accessing directly):
     R.Err_Value   →  R.Error_Value

3. NEW OPERATORS (Additive - no migration needed)
   Option: "or", "and", "xor"
   Result: "or"

   Example:
     Before: Int_Option.Unwrap_Or (Port_Option, 8080)
     After:  Port_Option or 8080

4. SEARCH AND REPLACE PATTERNS
   Pattern replacements for migration:
     \.Kind = K_Some      →  .Has_Value
     \.Kind = K_None      →  not .Has_Value  (or .Has_Value = False)
     \.Kind = K_Ok        →  .Is_Ok
     \.Kind = K_Err       →  not .Is_Ok
     \.Kind = K_Left      →  .Is_Left
     \.Kind = K_Right     →  not .Is_Left
     \bErr\s*\(           →  New_Error (
     \bIs_Err\b           →  Is_Error
     \bMap_Err\b          →  Map_Error
     \.Err_Value\b        →  .Error_Value
================================================================================
```

---

## Appendix: File Changes Summary

| File | Changes |
|------|---------|
| `src/functional-option.ads` | Discriminant, operators, new operations |
| `src/functional-option.adb` | Implementation updates |
| `src/functional-result.ads` | Discriminant, renames, operators, new operations |
| `src/functional-result.adb` | Implementation updates |
| `src/functional-either.ads` | Discriminant, new operations |
| `src/functional-either.adb` | Implementation updates |
| `test/unit/test_option.adb` | Discriminant updates, new tests |
| `test/unit/test_result.adb` | Discriminant updates, renames, new tests |
| `test/unit/test_either.adb` | Discriminant updates, new tests |
| `docs/quick_start.md` | Complete rewrite |
| `docs/migration-v3.md` | New file |
| `CHANGELOG.md` | Breaking changes documentation |
| `README.md` | Updated operation counts |

---

## Open Items

1. **Preelaborate verification**: Confirm Boolean discriminants maintain Preelaborate for Option after implementation.

2. **Operator precedence**: Document that `or`/`and`/`xor` follow Ada's standard precedence (may need parentheses in complex expressions).

3. **Generic formal naming**: Establish convention for generic formals across packages (e.g., `Make_Ok`, `Make_Some` vs `Mk_Ok`, `Mk_Some`).

**Recommendation:** Use `Make_` prefix consistently: `Make_Ok`, `Make_Error`, `Make_Some`, `Make_None`, `Make_Left`, `Make_Right`.
